<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen" />
    <title>Лекция 5 - Алгоритмизация и программирование</title>
</head>
<body><h1>Материалы курса <a href="../">Алгоритмизации и Программирования</a></h1>

<h2>Лекция 5 - "Упорядоченные и перечисляемые структуры данных".</h2>
<i>Преображенский М.В. 2021/22</i>

На этой лекции мы поговорим о том, как в памяти компьютера хранятся большие массивы данных и как программа может сохранять данные из оперативной памяти в файлы и загружать их обратно.

<h2>Структуры данных</h2>

До сих пор мы работали с одиночными переменными, каждая из которых представляла собой одну вещь или запись. Среди этих одиночных переменных особо выделяются строки, которые позволяют хранить большое количество информации в одной текстовой записи.

Для информации лежащей на диске строчное хранение вполне адекватно. Строки хорошо подходят для быстрой записи и быстрого считывания, а именно это и требуется от информации на диске. Но программа работает не на диске, а в оперативной памяти, в которой скорость записи и считывания и так уже очень велика. Поэтому гораздо важнее становятся вопросы управления данными и доступа к ним.

<defblock><def>Структуры данных</def> - способы организации информации, позволяющие управлять ею и получать к ней упорядоченный доступ.</defblock>

Сегодня мы поговорим о таких структурах данных, как: <ul>
    <li><def>Кортежи - неизменяемые наборы данных</def></li>
    <li><def>Списки - изменяемые наборы данных</def></li>
    <li><def>Множества - неповторяющийся неотсортированный набор данных</def></li>
    <li><def>Словари - данные, организованные по ключам</def></li></ul>

<h3>Кортеж</h3>

Самый простой способ организовать данные в структуру - перечислить их через запятую, например вот так:
<c>today = 2021, "октябрь", 27</c>

При выполнении такой строки, для переменной today в памяти компьютера создаётся <def>кортеж</def>.

<defblock><def>Кортеж (tuple)</def> - фиксированный последовательный набор данных.
    Будучи созданным, кортеж не подлежит дальнейшему изменению и будет существовать в первоначальном виде пока запись о нём есть в памяти.
    Кортеж является <def>перечисляемым (iterable)</def> и <def>упорядоченным (ordered)</def> типом данных.
    Конкретно упорядоченность так же делает кортежи <c>индексируемыми (subscribtable)</c></defblock>

Способы создания кортежей:<ul>
    <li>Прямое назначение - как в примере выше</li>
    <li>Использование скобок:<br>
        <c>today = (2021, "октябрь", 27)</c>.<br>
        В этой форме кортежи обычно выводятся на распечатку. Так же принято их хранить в текстовых файлах.</li>
    <li>Распаковка любого <c>перечисляемого</c> типа данных через <c>*</c>:<br>
        <c>today_again = *today</c></li>
    <li>Приведение любого <c>перечисляемого</c> типа данных к кортежу через tuple():<br>
        <c>today_once_more = tuple(today)</c></li></ul>

Возможности кортежей как <c>упорядоченного</c> типа данных:<ul>
    <li>Доступ к любому элементу по индексу:<br>
        <c>print(today[1])  # Октябрь</c><br>
        Доступ ТОЛЬКО НА ЧТЕНИЕ. Кортежи не подлежат изменениям.</li>
    <li>Срезы (получается новый кортеж):<br>
        <c>print(today[:2])  # (2021, "октябрь")</c></li>
    <li>Распаковка на элементы с помощью <c>*</c>:<br>
        <c>print(*today)  # идентично print(today[0], today[1], today[2])</c></li>
    <li>Распаковка в переменные:<br>
        <c>year, month, day = today</c><br>
        Количество элементов в распаковке должно совпадать с размером кортежа, но часть элементов можно выкинуть: <c>_, month, _ = today</c></li>
    <li>Совмещение двух кортежей (конкатенация, сложение) - создаётся новый кортеж!:<br>
        <c>a = (1, 2) + (3, 4, 5)  # (1, 2, 3, 4, 5)</c><br>
        Кортежи складываются только с кортежами.</li>
    <li>Повторение кортежа целое число раз (умножение) - создаётся новый кортеж!:<br>
        <c>a = (1, 2) * 10  # (1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2)</c></li></ul>

Возможности кортежей как <c>перечисляемого</c> типа данных:<ul>
    <li>Измерение длины через <c>len</c>:<br>
        <c>len(today)  # 3</c>
    <li>Использование как основы для перебора внутри for:<br>
        <c>for property in today:</c>
    <li>Проверка наличия значения в кортеже:<br>
        <c>if 2021 in today:</c>
    </li></ul>


<h3>Список</h3>

Кортежи позволяют группировать данные, но не позволяют позже менять порядок или состав группы. Тем не менее, в программах часто бывают ситуации, когда хочется иметь доступ к подобным изменениями. В таких случаях используют <def>списки</def>.

<defblock><def>Список (list)</def> - изменяемый последовательный набор данных.
    Как и кортеж, относится к <c>перечисляемым</c> и <c>упорядоченным</c> типам данных. Будучи <c>упорядоченным</c>, так же является <c>индексируемым</c></defblock>

Способы создания списков:<ul>
    <li>Использование квадратных скобок:<br>
        <c>empty_list = []
        days = [(2021, "октябрь", 27), (2021, "октябрь", 28), (2021, "октябрь", 29)]</c>.<br>
        В этой форме списки обычно выводятся на распечатку. Так же принято их хранить в текстовых файлах.</li>
    <li>Создание через list() без параметров или с перечисляемым параметром:<br>
        <c>empty_list = list()  # []
        list_of_today = list(today)  # [2021, "октябрь", 28]</c></li>
    <li>Встроенная функция sorted(), превращающее любой набор данных в отсортированных список:
        <c>numbers = sorted(1, 100, 10, 20, 50, 30)  # [1, 10, 20, 30, 50, 100]</c></li></ul>

Возможности списков как <c>упорядоченного</c> типа данных:<ul>
    <li>Доступ к любому элементу по индексу на чтение и на запись:<br>
        <c>print(days[1])  # (2021, "октябрь", 28)
        days[1] = (2022, "январь", 1)</c></li>
    <li>Срезы (получается новый список):<br>
        <c>print(days[:2])  # [(2021, "октябрь", 27), (2021, "октябрь", 28)]</c></li>
    <li>Распаковка в переменные:<br>
        <c>today, tomorrow, _ = days</c><br>
    <li>Распаковка на элементы с помощью <c>*</c>:<br>
        <c>print(*days)  # идентично print(days[0], days[1], days[2])</c></li>
    <li>Совмещение двух списков (конкатенация, сложение) - создаётся новый список!:<br>
        <c>a = [1, 2] + [3, 4, 5]  # [1, 2, 3, 4, 5]</c><br>
        Списки складываются только со списками.</li>
    <li>Повторение списка целое число раз (умножение) - создаётся новый список!:<br>
        <c>a = [1, 2] * 10  # [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]</c></li></ul>

Возможности списков как <c>перечисляемого</c> типа данных:<ul>
    <li>Измерение длины через <c>len</c>:<br>
        <c>len(days)  # 3</c></li>
    <li>Использование как основы для перебора внутри for:<br>
        <c>for day in days:</c>
    <li>Проверка наличия элемента внутри списка:<br>
        <c>if day in days:</c></li></ul>

У списков так же есть большое число встроенных функций. Вот несколько наиболее важных:<ul>
    <li>Добавление элемента в конец списка:<br>
        <c>days.append(today)</c></li>
    <li>Добавление элемента в середину списка по индексу:<br>
        <c>a = [1, 2, 3]
        a.insert(1, 5)  # [1, 5, 2, 3]</c></li>
    <li>Забор элемента из списка по индексу (при этом элемент удаляется из списка!):<br>
        <c>day_gone = days.pop(0)
        last_day = days.pop()</c></li>
    <li>Сортировка списка:<br>
        <c>days.sort()</c></li></ul>


<h3>Множество</h3>

Иногда возникают ситуации, когда порядок данных абсолютно не важен, но важно чтобы они не повторялись. В таких случаях используют <def>множества</def>.

<defblock><def>Множество (set)</def>: неупорядоченный набор данных, в котором гарантируется уникальность каждого элемента.
Не являясь индексируемым (а тем более упорядоченным), тем не менее является <c>перечисляемым</c>: все элементы множества можно по одному перебрать, просто нельзя рассчитывать что они будут в каком-то порядке.</defblock>

Способы создания множеств:<ul>
    <li>Использование фигурных скобок:<br>
        <c>days = {(2021, "октябрь", 27), (2021, "октябрь", 28), (2021, "октябрь", 29)}</c>.<br>
        В этой форме множества обычно выводятся на распечатку. Так же принято их хранить в текстовых файлах.</li>
    <li>Создание через set() без параметров или с перечисляемым параметром:<br>
        <c>empty_set = set()  # {}
        set_of_today = set(today)  # {"октябрь", 28, 2021} (порядок случайный) </c></li></ul>

Так как множества не индексированы, нельзя получать доступ к отдельным элементам по индексам.
Для доступа к множеству используют перечисления!

Возможности множеств как <c>перечисляемого</c> типа данных:<ul>
    <li>Измерение длины через <c>len</c>:<br>
        <c>len(days)  # 3</c></li>
    <li>Использование как основы для перебора внутри for:<br>
        <c>for day in days:</c>
    <li>Проверка наличия элемента внутри множества:<br>
        <c>if day in days:</c></li></ul>

Так же как у списков, у множеств есть большое число встроенных функций. В случае с множествами, функционал построен вокруг математической теории множеств. Вот несколько наиболее важных:<ul>
    <li>Добавление элемента к множеству (если элемент уже есть, то ничего не изменится):<br>
        <c>days.add(today)</c></li>
    <li>Удаление элемента из множества:<br>
        <c>days.discard(today)
            days.remove(today)  # более требователен, даст ошибку элемента нет</c></li>
    <li>Объединение множеств:<br>
        <c>a = {1, 2, 3} | {1, 3, 5}  # {1, 2, 3, 5}</c></li>
    <li>Вычитание множеств:<br>
        <c>a = {1, 2, 3} - {1, 3, 5}  # {1, 2}</c></li></ul>


<h3>Словарь</h3>

Одним из неожиданных, но популярных применений множества оказалась ситуация, когда каждому значению множества ставится в соответствие другое значение. Это <def>Словарь</def>.

<defblock><def>Словарь (dictionary, dict)</def>: структура данных в Питоне, в которой организованные как множество неповторяющихся элементов <def>ключи</def> указывают на (возможно повторяющиеся) <def>значения</def>.
Словари относятся к <c>перечислямому</c> типу и, хотя они и не упорядочены, они относятся к <c>индексируемым</c>, но в роли индексов выступают <def>ключи</def>, а не числа</defblock>

Словари оказались настолько более популярны чем сами множества, что в Питоне пустые фигурные скобки означают не пустое множество, а пустой словарь!

Способы создания словарей:<ul>
    <li>Использование фигурных скобок:<br>
        <c>empty_dict = {}
        days_dict = {'today': (2021, "октябрь", 27), 'tomorrow': (2021, "октябрь", 28) }</c>.<br>
        В этой форме словари обычно выводятся на распечатку. Так же принято их хранить в текстовых файлах.</li>
    <li>Создание через dict():<br>
        <c>empty_dict = dict()</c></li></ul>

Возможности словарей как <c>индексируемого</c> типа данных:<ul>
    <li>Чтение и запись элементов по ключу:
        <c>print(days_dict['today'])  # (2021, "октябрь", 27)
        days_dict['today'] = "перезаписали значение по ключу 'today'"</c></li></ul>

Возможности словарей как <c>перечисляемого</c> типа данных:<ul>
    <li>Измерение числа ключей через <c>len</c>:<br>
        <c>len(days_dict)  # 2</c></li>
    <li>Использование как основы для перебора внутри for (и тогда перебираются ключи):<br>
        <c>for key in days_dict:</c>
    <li>Проверка наличия ключа в словаре:<br>
        <c>if key in key_dict:</c></li></ul>

К встроенным функциям словарей обращаются редко, но стоит отметить убирающую ключ из словаря функцию pop():
<c>today = days_dict.pop("today")</c>
Так же как и со списками, она убирает ключ из словаря и возвращает лежавшее по этому ключу значение.
</body>
