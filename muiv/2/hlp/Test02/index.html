<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../../../style.css" media="screen" />
    <title>Тест 2 - Высокоуровневые методы программирования</title>
    <style>li { margin-top: 10px; }</style>
</head>
<body><h1>Материалы курса <a href="../">Высокоуровневые методы программирования</a></h1>
<cite>Преображенский М.В. 2021/22</cite>

<h1>Тест от 26.11.2021 - функции и классы.</h1>

Тест можно сдать на бумаге, или онлайн в этой форме: <a href="https://forms.yandex.ru/u/61a0709cdb879f37898990e2/">ссылка</a>

<h2>Правила теста:</h2>

Запрещающих правил нет, вы можете использовать весь известный Вам функционал Python (как пройденный на лекциях, так и нет).

В некоторых задачах Вам будет предлагаться использовать классы или переменные из предыдущих задач. В этом случае Вам не надо писать их заново. Вы можете свободно обращаться к уже написанному в прошлых задачах функционалу.

Импорт библиотеки datetime так же прописывать не нужно. Во всех случаях считайте, что она уже импортирована.

На 5 нужно дать 10 правильных ответов, либо 9 правильных ответов и качественный ответ на доп. вопрос (качество определяет преподаватель).

Удовлетворительным считается результат с 7 правильными ответами (не зависимо от доп. вопроса).

<h2>Вопросы:</h2>

<b>Вопрос 1</b>

Вы получили задание - написать программу для обеспечения курса истории, в котором ключевым объектом выступает хронологическое событие (напр. крещение Руси или Куликовская битва).

Напишите класс <c>ChronEvent</c>, который будет при инициализации каждого нового экземпляра получать и сохранять в памяти два значения: время события (<c>datetime</c>) и название события (<c>name</c>).

<b>Вопрос 2</b>

Хочется иметь возможность выводить сохранённые события на печать!
Напишите функцию <c>__str__</c>, которая могла бы существовать в классе <c>ChronEvent</c> и возвращать строку распечатки конкретного события в следующем формате:
<c>f"CE - {self.datetime}: {self.name}"</c>

<b>Вопрос 3</b>

Хронологические события должны быть расположены в последовательностях - хрониках!
Напишите класс <c>Chronicle</c>, который будет содержать в себе список событий.
Класс должен при создании получать имя - название хроники - и создавать внутри себя пустой список для хронологических событий. Класс так же должен иметь две функции:

<c>add(chron_event)</c>, которая позволит добавить в его список переданное как параметр событие.
<c>combine(other_chronicle)</c>, которая позволит добавить в список одной хроники все события из переданной списка другой хроники.

<b>Вопрос 4</b>

Хронологические события должны основываться на исторических документах. При этом одно историческое событие может упоминаться в большом числе документов, а документ может упоминать большое число событий. Документ может так же содержать какие-то хроники, крупные или не очень (например, какой-то князь сначала сходил в поход, потом женился).
Создайте класс <c>Document</c>, который при создании имеет внутри себя пустое множество хроник, а так же имеет функцию <c>attach(event, chronicle=None)</c>, которая позволяет привязывать к документу события, возможно одновременно добавляя их к какой-то хронике.

<b>Вопрос 5</b>

Хроники так же надо уметь выводить на печать!
Напишите соответствующую процедуру для класса Chronicle, которая выводила бы на печать список событий хроники в следующем формате:
<c>f"Хроника {self.name}:
{распечатка события 0}
{распечатка события 1}..."</c>
итд.

<b>Вопрос 6</b>

При распечатке хроник мы заметили, что события не упорядочены. Они добавляются вразнобой по мере анализа историками исторических документов.

Напишите модифицированный метод <c>add(event)</c> в классе <c>Chronicle</c>, который будет не просто добавлять событие в список, а добавлять его в хронологическом порядке (то есть перед событиями с большим <c>datetime</c>, но после событий с меньшим <c>datetime</c>)

** исходите из того, что значения <c>datetime</c> можно напрямую сравнивать между собой обычными операторами сравнения

<b>Вопрос 7</b>

При анализе хроник мы заметили, что одно и то же событие может подаваться под разным названием и даже с разными датировками!

Создайте класс <c>ChronIdentity</c>, который будет содержать в себе список считаемых идентичными событий.

Класс ChronIdentity создаётся из кортежа событий и сохраняет в себе этот кортеж. Он так же должен иметь свойство (<c>@property</c>) <c>name</c>, которое будет возвращать имя первого события в кортеже.

<b>Вопрос 8</b>

Историки долго работали, устанавливая хронологии и совпадения событий. И тут один из них пришёл к Вам со странной проблемой! Оказывается, в двух хрониках два набора идентичных событий идут в разных последовательностях! В одной хронике царь женился, потом уехал на войну (и там погиб). А в другой он сначала уехал на войну, а потом женился (то есть погибнуть никак не мог!). Как такое может быть?

Вы пока не очень понимаете, что делать, но на всякий случай решили написать функцию проверки.

Напишите свободную функцию <c>verify(identity1, identity2, chronicle1, chronicle2)</c>
Эта функция будет брать две идентичности, находить положение соответствующих им событий в хрониках, после чего писать "Ok" если их порядок в хрониках совпадает, "Not ok" если нет и "N/A" если в хотя бы в одной их хроник нет событий хотя бы одной из идентичностей.

<b>Вопрос 9</b>

Думая над тем, как анализировать проблемы хронологии, Вы решаете прописать логику исключения событий. Понятно, например, что князь не мог погибнуть на войне, а потом жениться! С другой стороны, если он погиб на войне то наверно должна была быть война!

Дополните в класс <c>Identity</c> два метода:
<c>require(other_identity)</c> и
<c>prevent(other_identity)</c>
Результатом работы этих методов должно быть сохранение в объектах класса <c>Identity</c> информации о том, какие другие <c>Identity</c> должны были обязательно произойти, чтобы случилось это событие (метод <c>require</c>), а какие произойти после этого события не могут (метод <c>prevent</c>).

В качестве ответа приведите весь код обновлённого класса <c>Identity</c> целиком.

<b>Вопрос 10</b>

Хронология - логически непротиворечивая последовательность событий.

Создайте класс <c>Chronology</c>, который при создании берёт список хроник <c>chronicles</c> и список идентичных событий <c>identity</c>. В элементах списка <c>identity</c> уже вызваны методы <c>require</c> и <c>prevent</c>, и тем самым прописаны требования и исключения по отношению к другим идентичностям.

Напишите метод внутри класса метод verify, который проверит, что внутри хронологии происходят все требуемые события. А так же проверит, что внутри хронологии не происходят события, возможность которых исключена уже произошедшими.

При наличии противоречий, на печать должны выводиться либо два противоречащих друг другу события (именно события, а не идентичности).

<b>Дополнительный вопрос</b>

Подумайте о предложенной архитектуре анализа хронологий. Как Вам кажется, какие у этой архитектуры есть достоинства и какие недостатки.

В своём ответе обсудите вопросы требуемого функционала, памяти и производительности.
</body>
