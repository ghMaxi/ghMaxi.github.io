<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../../../style.css" media="screen" />
    <title>Лекция 5 - Высокоуровневые методы программирования</title>
</head>
<body><h1>Материалы курса <a href="../">«Высокоуровневые методы программирования»</a></h1>
<cite>Преображенский М.В. 2021/22</cite>

<h1>Лекция 5: "Способы выделения классов".</h1>

На прошлой лекции мы обсудили технический процесс создания классов и синтаксис их создания в языке Python. На этой мы обсудим типологию классов, как и когда они выделяются из программы.

<h2>Проблема понимания предметной области.</h2>

Для того, чтобы эффективно выделять подпрограммы в классы, мало понимать техническое преимущество такого выделения перед функциями. Надо так же понимать, зачем это выделение осуществляется. Если с функциями всё достаточно прямолинейно: мы делим большой обьём работы на части и по частям его описываем, то для того, чтобы понять классы, нужно сначала понять идею <def>предметной области</def>.

<defblock><def>Предметная область</def> - термин из теории познания, обозначающий связанную группу понятий о конкретно существующих предметах и феноменах, объединённых вместе в рамках какого-то общего контекста.</defblock>

Например, может существовать предметная область "Авиаполёты", в рамках которой могут существовать такие предметы как "Самолёт", "Фюзеляж", "Крыло". На так же, например, такие феномены как "Скорость, равнодействующее давление воздуха". Процесс создания любой полноценной симуляции самолёта в виртуальном пространстве обязательно должен учитывать связь между всеми этими понятиями.

Программист, работающий с классами, воссоздаёт предметную область, описывая её в своей программе на языке программирования.
Рассмотрим этот процесс, а так же кое-какие принципы работы с объектами, на примерах.

<h2>Принцип единой ответственности как основа для выделения класса.</h2>

Допустим, что мы действительно хотим сделать симулятор авиаперевозок. И в рамках этого симулятора нам нужен самолёт, который мы будет отрисовывать на экране. Для такой отрисовки, нам необходимо соединить вместе информацию о модели такого самолёта, а так же его расположение в пространстве и поворот.
Допустим, у нас пока нет кода отрисовывающего самолёт, а модели самолётов мы предполагаем хранить в какой-то таблице по какому-то <c>id</c> (но самой таблицы у нас тоже пока нет).
Для целей тестирования нашей системы мы можем написать функцию такого рода:

<c>def DrawPlane(plane_id, position, rotation):
    print(f'Самолёт {plane_id}: Расположение: {position}; Поворот: {rotation};'</c>

После чего можем вызывать функцию в бесконечном цикле:

<c>if __name__ == "__main__":
    model_id = 1
    rotation = 0
    position = 0
    speed = 1
    while True:
        position += speed
        DrawPlane(model_id, position, rotation)</c>

Запуск этой программы покажет нам, что наш самолёт потихоньку едет вперёд (мы увидим это в распечатках). Но дальше встаёт вопрос - отражает ли эта программу реальную работу нашей <def>предметной области?</def>
И ответ будет - отражает, но очень плохо. И дело даже не в том, что наш самолёт пока движется строго по прямой, а в том, что он не будет двигаться равномерно! У него должно быть ускорение, а ускорение зависит от модели самолёта!

Модифицируем нашу программу таким образом, чтобы ускорение зависело от модели самолёта. То есть наша модель должна содержать в себе не только информацию о своём порядковом номере, но и информацию об ускорении:

<c>class PlaneModel:
    def __init__(id):
        self.acceleration = id, acceleration

<c>if __name__ == "__main__":
    model = PlaneModel(1)
    rotation = 0
    position = 0
    speed = 0
    while True:
        speed += model.acceleration
        position += speed
        DrawPlane(model.id, position, rotation)</c>
<c>getAcceleration(model_id):

    return 1    # тестовое значение ускорения для любой модели

getVerticalSpeed(model_id, horizontal_speed):
    return horizontal_speed - 10     # тестовый рассчёт. Надо разогнаться до 10 чтобы начать взлетать</c>

Наша программа модифицируется далее:
<c>if __name__ == "__main__":
    model_id = 1
    rotation = [0, 0, 0]
    position = [0, 0, 0]
    speed = [0, 0, 0]
    while True:
        position = [position[0] + speed[0], position[1] + speed[1], position[2] + speed[2]]
        DrawPlane(model_id, position, rotation)</c>

А наш
Если продолжать писать программу в функциональном стиле, то получается что-то такое:

После завершения функции копии аргументов пропадают из памяти программы. Предполагается, что к этому моменту функция должна была вернуть или другим образом зафиксировать все имеющие значение для программы данные.

Но что делать, если таких значений слишком много? Или они находятся внутри жёсткой структуры, о которой другие функции ничего не знают?

Ниже пример программы, в которой функциям приходится работать с большими группами значений. Эта программа держит список пользователей, которым можно изменять статусы и добавлять купленные продукты.

В этой программе есть 2 ошибки. Сможете найти?:
<img src="1.png" />

Чтобы найти ошибки в этой программе, создадим ей небольшой тест:
<img src="2.png" />
Тест сначала покажет ошибку при выполнении <c>add_user_product</c>, а потом покажет что в итоге информация о пользователе сохраняется неправильно - всё из-за того что мы запутались в индексах!

Такая вот путаница при работе с параметрами является одним из фундаментальных ограничений чистого функционального подхода. Ещё одним является необходимость переделывать все функции, работающие с группой данных при изменении этой группы данных.

<h2>Классы как способ организации данных.</h2>

Создадим для предыдущей программы класс User, который будем использовать для хранения и организации всех необходимых данных.
<defblock><def>класс</def> - новый, созданный пользователем тип данных, в рамках которого создаются, хранятся и преобразовываются разнообразные значения.
<def>поля класса</def> - создаются непосредственно внутри описания класса и привязываются к классу напрямую. Хранятся в программе в единственном виде и доступны всем частям программы, которым доступен класс.
</defblock>

Рассматривая код ниже, обратите внимание на:
<ul>
    <li>Использование ключевого слова <c>class</c>, с двоеточием и отступом.</li>
    <li>Тот факт, что полями класса могут быть как переменные (<c>DEFAULT_STATUS</c> и <c>DEFAULT_LICENCE</c>), так и методы (<c>__init__</c>).</li>
    <li>Тот факт, что <c>__init__</c> берёт <c>self</c> как обязательный параметр, а кроме него может брать ещё и другие.</li>
    <li>Тот факт, что данные, привязанные к конкретному пользователю, а не просто к пользователям как идее, назначаются внутри метода <c>__init__ </c>
    <li>Тот факт, что поля класса используются через <c>USER.Поле</c>.
</ul><img src="3.png" />

Создав класс User, мы организовали данные о пользователе, а так же определили стандартную процедуру создания нового пользователя.
Теперь мы можем создавать новых пользователей так:
<c>new_user = User("имя", "пароль")</c>

Получив такую инструкцию, Питон выполнит следующие действия:
<ol><li>Обратится к классу User, зарезервирует адрес в памяти под новый объект (и выполнит другие необходимые действия), сохранит ссылку на это место в переменную <c>self</c></li>
    <li>Вызовет метод <c>User.__init__</c>, передав ему в качестве параметров свежеиспечённый <c>self</c>, а так же те параметры, которые мы указали в скобках при вызове.</li>
    <li>Выполнит весь алгоритм <c>__init__</c>, в рамках которого к новому объекту <c>self</c> будут привязаны принадлежащие конкретно этому объекту данные с использованием <c>self.имя</c>.</li>
    <li>Сохранит в переменную <c>new_user</c> результат работы: значение <c>self</c>, в котором все данные уже назначены по именам.</li>
</ol>После чего, например, имя пользователя станет доступно для чтения и изменения через:
<c>new_user.username</c>
<defblock><def>instance</def> - технический термин для описания конкретного объекта, принадлежащего к конкретному классу.

Например, в примере выше мы создали <b>instance</b> класса <c>User</c> и сохранили его в переменную <c>new_user</c>.

Слово <b>instance</b> в среде программистов обычно переводится на русский как "экземпляр". Но чаще мы просто прямо называем подобных представителей своих классов тем, что они есть (в примере выше это пользователь).
</defblock>

Сохранив класс <c>User</c> в файл <b>user.py</b>, перепишем нашу исходную программу. Обратите внимание на следующие моменты:
<ul><li>Списку <c>users</c> теперь можно явно указать, какие данные в нём лежат. Это помогает с автозаполнением.</li>
    <li>Из трёх наших функций две оказались не актуальны, поскольку легко заменяются прямыми обращениями к внутренним переменным конкретного пользователя.</li>
    <li>Одна оставшаяся функция большую часть своего функционала передала внутрь <c>User.__init__</c>. Теперь она отвечает только за автоматическую передачу нового пользователя в список.</li>
</ul><img src="4.png" />

Насколько понятнее и чище стал наш код видно невооружённым глазом.

<h2>Распечатка объектов.</h2>

В предыдущем разделе всё было хорошо, но есть проблема. Итоговый код при запуске вместо данных печатает следующее:
<c>&lt;user.User object at 0x0000025335A4FFD0&gt;</c>

Фактически, распечатка просто говорит нам, что печатается объект User, лежащий по определённому адресу в памяти компьютера (адрес может и будет меняться между запусками).
Если раньше мы печатали простой и понятный кортеж, то сейчас Питон не знает, как ему печатать этот объект.

Но откуда он берёт эту строчку? Ответ прост - внутри класса <c>User</c> есть набор встроенных методов, и <c>print</c>, выводя на экран распечатку, обращается к одному из них - методу <c>__str__</c> (все системные методы классов в Питоне выделяются двойными подчёркиваниями).

Давайте объясним Питону, как надо нашего пользователя выводить на печать! Для этого в классе <c>User</c> добавим вот такой метод <c>__str__</c>:
<img src="5.png" />
Обратите внимание на следующие моменты:
<ul><li>Системная функция <c>vars</c> позволяет получить словарь всех внутренних переменных любого объекта в Питоне.</li>
    <li>Метод <c>str</c> возвращает идущую на распечатку строку.</li>
    <li>PyCharm обозначил метод <c>str</c> синей иконкой с буквой О слева, что означает что этот метод переопределяет (англ.: override) какой-то существующий функционал. В данном случае, переопределяется системная распечатка.</li>
</ul>

Таким образом, мы подменили один из внутренних методов класса <c>User</c> своим, изменим тем самым работу системной функции <c>print</c>. В будущем, мы узнаем и о других таких системных функциях. Те, кому интересно, могут сразу почитать <a href="https://pythonworld.ru/osnovy/peregruzka-operatorov.html">документацию на русском</a>.

<h2>Методы экземпляров класса.</h2>

Питон позволяет получать доступ к внутренним элементам класса напрямую, но чаще мы ходим осуществлять какое-то координированное изменение.
Например, возможно в нашей программе про пользователей мы считаем пользователя новичком только пока он не купил ни одного продукта. А когда он купил продукт, он автоматически должен становиться "бывалым".

Пометим наш список продуктов как закрытый для внешнего использования, и пропишем нашему пользователю функцию, которая будет гарантировать такое изменение при каждом добавлении нового продукта!
<img src="6.png" />

Теперь, при попытке напрямую обратиться к списку продуктов с нижним подчёркиванием, PyCharm будет предупреждать нас что так делать нельзя:
<img src="7.png" />

Вместо такого обращения, мы должны вызывать функцию <c>add_product</c>.

Её полный вызов выглядит вот так:
<c>User.add_product(users[0], "minecraft")</c>

Но в Python принято сокращать подобные вызовы до вот таких:
<c>users[0].add_product("minecraft")</c>

Таким образом, мы можем добавить снаружи нашей программы новый продукт любому пользователю, не беспокоясь при этом о его статуса (пользователь сам со всем разберётся).
</body>
</html>
