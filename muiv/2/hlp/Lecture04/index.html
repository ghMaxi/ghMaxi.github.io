<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../../../pre2.css" media="screen" />
    <title>Лекция 4 - Высокоуровневые методы программирования 2</title>
</head>
<body><h1>Материалы курса Высокоуровневые методы программирования</h1>

<h2>Лекция 4 - "Выделение подпрограмм - классы".</h2>
<i>Преображенский М.В. 2021/22</i>

На этой лекции мы обсудим, что такое класс и как с помощью классов можно делить программу на подпрограммы.

<h2>Ограничения чистого функционального подхода.</h2>

На прошлой лекции мы обсудили <b>функции</b> и способы их выделения из программы. Напоминаю, что функция имеет имя и аргументы, при этом в момент запуска функции создаются копии всех аргументов, которые хранятся в памяти пока работает функция.

После завершения функции копии аргументов пропадают из памяти программы. Предполагается, что к этому моменту функция должна была вернуть или другим образом зафиксировать все имеющие значение для программы данные.

Но что делать, если таких значений слишком много? Или они находятся внутри жёсткой структуры, о которой другие функции ничего не знают?

Ниже пример программы, в которой функциям приходится работать с большими группами значений. Эта программа держит список пользователей, которым можно изменять статусы и добавлять купленные продукты.

В этой программе есть 2 ошибки. Сможете найти?:
<img src="1.png" />

Чтобы найти ошибки в этой программе, создадим ей небольшой тест:
<img src="2.png" />
Тест сначала покажет ошибку при выполнении <c>add_user_product</c>, а потом покажет что в итоге информация о пользователе сохраняется неправильно - всё из-за того что мы запутались в индексах!

Такая вот путаница при работе с параметрами является одним из фундаментальных ограничений чистого функционального подхода. Ещё одним является необходимость переделывать все функции, работающие с группой данных при изменении этой группы данных.

<h2>Классы как способ организации данных.</h2>

Создадим для предыдущей программы класс User, который будем использовать для хранения и организации всех необходимых данных.
<defblock><def>класс</def> - новый, созданный пользователем тип данных, в рамках которого создаются, хранятся и преобразовываются разнообразные значения.
<def>поля класса</def> - создаются непосредственно внутри описания класса и привязываются к классу напрямую. Хранятся в программе в единственном виде и доступны всем частям программы, которым доступен класс.
</defblock>

Рассматривая код ниже, обратите внимание на:
<ul>
    <li>Использование ключевого слова <c>class</c>, с двоеточием и отступом.</li>
    <li>Тот факт, что полями класса могут быть как переменные (<c>DEFAULT_STATUS</c> и <c>DEFAULT_LICENCE</c>), так и методы (<c>__init__</c>).</li>
    <li>Тот факт, что <c>__init__</c> берёт <c>self</c> как обязательный параметр, а кроме него может брать ещё и другие.</li>
    <li>Тот факт, что данные, привязанные к конкретному пользователю, а не просто к пользователям как идее, назначаются внутри метода <c>__init__ </c>
    <li>Тот факт, что поля класса используются через <c>USER.Поле</c>.
</ul><img src="3.png" />

Создав класс User, мы организовали данные о пользователе, а так же определили стандартную процедуру создания нового пользователя.
Теперь мы можем создавать новых пользователей так:
<c>new_user = User("имя", "пароль")</c>

Получив такую инструкцию, Питон выполнит следующие действия:
<ol><li>Обратится к классу User, зарезервирует адрес в памяти под новый объект (и выполнит другие необходимые действия), сохранит ссылку на это место в переменную <c>self</c></li>
    <li>Вызовет метод <c>User.__init__</c>, передав ему в качестве параметров свежеиспечённый <c>self</c>, а так же те параметры, которые мы указали в скобках при вызове.</li>
    <li>Выполнит весь алгоритм <c>__init__</c>, в рамках которого к новому объекту <c>self</c> будут привязаны принадлежащие конкретно этому объекту данные с использованием <c>self.имя</c>.</li>
    <li>Сохранит в переменную <c>new_user</c> результат работы: значение <c>self</c>, в котором все данные уже назначены по именам.</li>
</ol>После чего, например, имя пользователя станет доступно для чтения и изменения через:
<c>new_user.username</c>
<defblock><def>instance</def> - технический термин для описания конкретного объекта, принадлежащего к конкретному классу.

Например, в примере выше мы создали <b>instance</b> класса <c>User</c> и сохранили его в переменную <c>new_user</c>.

Слово <b>instance</b> в среде программистов обычно переводится на русский как "экземпляр". Но чаще мы просто прямо называем подобных представителей своих классов тем, что они есть (в примере выше это пользователь).
</defblock>

Сохранив класс <c>User</c> в файл <b>user.py</b>, перепишем нашу исходную программу. Обратите внимание на следующие моменты:
<ul><li>Списку <c>users</c> теперь можно явно указать, какие данные в нём лежат. Это помогает с автозаполнением.</li>
    <li>Из трёх наших функций две оказались не актуальны, поскольку легко заменяются прямыми обращениями к внутренним переменным конкретного пользователя.</li>
    <li>Одна оставшаяся функция большую часть своего функционала передала внутрь <c>User.__init__</c>. Теперь она отвечает только за автоматическую передачу нового пользователя в список.</li>
</ul><img src="4.png" />

Насколько понятнее и чище стал наш код видно невооружённым глазом.

<h2>Распечатка объектов.</h2>

В предыдущем разделе всё было хорошо, но есть проблема. Итоговый код при запуске вместо данных печатает следующее:
<c>&lt;user.User object at 0x0000025335A4FFD0&gt;</c>

Фактически, распечатка просто говорит нам, что печатается объект User, лежащий по определённому адресу в памяти компьютера (адрес может и будет меняться между запусками).
Если раньше мы печатали простой и понятный кортеж, то сейчас Питон не знает, как ему печатать этот объект.

Но откуда он берёт эту строчку? Ответ прост - внутри класса <c>User</c> есть набор встроенных методов, и <c>print</c>, выводя на экран распечатку, обращается к одному из них - методу <c>__str__</c> (все системные методы классов в Питоне выделяются двойными подчёркиваниями).

Давайте объясним Питону, как надо нашего пользователя выводить на печать! Для этого в классе <c>User</c> добавим вот такой метод <c>__str__</c>:
<img src="5.png" />
Обратите внимание на следующие моменты:
<ul><li>Системная функция <c>vars</c> позволяет получить словарь всех внутренних переменных любого объекта в Питоне.</li>
    <li>Метод <c>str</c> возвращает идущую на распечатку строку.</li>
    <li>PyCharm обозначил метод <c>str</c> синей иконкой с буквой О слева, что означает что этот метод переопределяет (англ.: override) какой-то существующий функционал. В данном случае, переопределяется системная распечатка.</li>
</ul>

Таким образом, мы подменили один из внутренних методов класса <c>User</c> своим, изменим тем самым работу системной функции <c>print</c>. В будущем, мы узнаем и о других таких системных функциях. Те, кому интересно, могут сразу почитать <a href="https://pythonworld.ru/osnovy/peregruzka-operatorov.html">документацию на русском</a>.

<h2>Методы экземпляров класса.</h2>

Питон позволяет получать доступ к внутренним элементам класса напрямую, но чаще мы ходим осуществлять какое-то координированное изменение.
Например, возможно в нашей программе про пользователей мы считаем пользователя новичком только пока он не купил ни одного продукта. А когда он купил продукт, он автоматически должен становиться "бывалым".

Пометим наш список продуктов как закрытый для внешнего использования, и пропишем нашему пользователю функцию, которая будет гарантировать такое изменение при каждом добавлении нового продукта!
<img src="6.png" />

Теперь, при попытке напрямую обратиться к списку продуктов с нижним подчёркиванием, PyCharm будет предупреждать нас что так делать нельзя:
<img src="7.png" />

Вместо такого обращения, мы должны вызывать функцию <c>add_product</c>.

Её полный вызов выглядит вот так:
<c>User.add_product(users[0], "minecraft")</c>

Но в Python принято сокращать подобные вызовы до вот таких:
<c>users[0].add_product("minecraft")</c>

Таким образом, мы можем добавить снаружи нашей программы новый продукт любому пользователю, не беспокоясь при этом о его статуса (пользователь сам со всем разберётся).

<h2>Статичные методы и методы класса.</h2>

Внутри класса так же могут определяться статичные методы и методы класса:


</body>
</html>
