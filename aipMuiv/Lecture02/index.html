<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../style.css" media="screen" />
    <title>Лекция 2 - Алгоритмизация и программирование</title>
</head>
<body><h1>Материалы курса <a href="../">«Алгоритмизации и Программирования»</a></h1>
<cite>Преображенский М.В. 2021/22</cite>

<h1>Лекция 2 - Значения, форматы и операторы</h1>

На этой лекции мы разберёмся с тем, как именно работают переменные в Python, где они находятся и какие с ними можно выполнять операции.


<h2>Значения и форматы на физических носителях.</h2>

На картинке ниже представлено устройство компьютера. Как Вы думаете, где именно хранятся переменные значения программы?

<img src="./cpuInside.jpg" />
<b>Ответ (выделить):</b> <span class="hidden">Оперативная память</span>


В зависимости от носителя, значения в памяти могут храниться в разной форме:

<img class="inline" src="./cd.jpg"/><img class="inline" src="./ssd.jpg"/>

В оперативной памяти значения хранятся в виде электрических сигналов и существуют только пока им подаётся электрический ток. Прекращение подачи тока "гасит" значения.

<B>ВАЖНО:</B> Обратите внимание, что на таком низком уровне нигде нет физических 0 или 1. Их и нигде не может быть - числа 0 и 1 не являются физическими телами, это существующие в наших головах идеи.

Мы смотрим на физическое состояние носителя в конкретном физическом секторе памяти и определяем его как цифру 0 или цифру 1 согласно некоторому заранее согласованному <b>формату</b>.
Таким образом, с помощью форматов мы выделяем из набора разнообразных сигналов то, что имеет <b>значение</b>.
<defblock><def>Значение</def> - понятие, наделённое смыслом в рамках заранее существующей договорённости.
    Например, понятия '0' и '1' имеют смысл только в рамках договорённости о двоичном коде.
<def>Данные</def> - значения измеримых параметров (например, в памяти компьютера).
<def>Формат</def> - способ считывания данных, дающий новое значение.</defblock>


<h2>Типы данных в памяти компьютера.</h2>

Мы разобрали, где и каким образом в памяти компьютера хранятся значения 0 и 1, а так же обсудили вопрос первичного формата, позволяющего считывать эти значения с конкретного физического носителя.
Теперь поговорим о том, как в компьютере могут храниться более сложные значения.

<h3>Тип данных: целое число.</h3>

Договорившись о том, как читать из физической памяти значения 0 и 1, программисты и компьютерные инженеры начали дальше договариваться о том, как читать группы 0 и 1. Так началось усложнение <b>типов данных</b>.
Первой такой договорённостью стало использование 0 и 1 компьютера как цифр двоичной записи числа. Этот формат получил название <b>BIN</b> (от слова binary).
Одновременно с BIN родился формат <b>DEC</b> (decimal), представляющий соответствующее двоичному коду десятичное число.
Почти тут же возник формат HEX, в котором 4 соседних бита объединяются в 1 символ и получается шестнадцатеричное число.

Примеры записи нескольких чисел в разных форматах приведены ниже:

<cite>Сгенерировано этим кодом на python:</cite>
    <code>print(f'DEC\tBIN\t\t\tHEX\t\t\tDEC\tBIN\t\t\tHEX')
for i in range(1, 34, 2):
    print(f'{i:>2}:\t{bin(i):9}:\t{hex(i):4};\t\t{i+1:>2}:\t{bin(i+1):9}:\t{hex(i+1):4};')</code>

    DEC	BIN		HEX		DEC	BIN		HEX
     1:	0b1      :	0x1 ;		 2:	0b10     :	0x2 ;
     3:	0b11     :	0x3 ;		 4:	0b100    :	0x4 ;
     5:	0b101    :	0x5 ;		 6:	0b110    :	0x6 ;
     7:	0b111    :	0x7 ;		 8:	0b1000   :	0x8 ;
     9:	0b1001   :	0x9 ;		10:	0b1010   :	0xa ;
    11:	0b1011   :	0xb ;		12:	0b1100   :	0xc ;
    13:	0b1101   :	0xd ;		14:	0b1110   :	0xe ;
    15:	0b1111   :	0xf ;		16:	0b10000  :	0x10;
    17:	0b10001  :	0x11;		18:	0b10010  :	0x12;
    19:	0b10011  :	0x13;		20:	0b10100  :	0x14;
    21:	0b10101  :	0x15;		22:	0b10110  :	0x16;
    23:	0b10111  :	0x17;		24:	0b11000  :	0x18;
    25:	0b11001  :	0x19;		26:	0b11010  :	0x1a;
    27:	0b11011  :	0x1b;		28:	0b11100  :	0x1c;
    29:	0b11101  :	0x1d;		30:	0b11110  :	0x1e;
    31:	0b11111  :	0x1f;		32:	0b100000 :	0x20;
    33:	0b100001 :	0x21;		34:	0b100010 :	0x22;</pre>


Таким образом, компьютер научился представлять целые числа как <b>ТИП ДАННЫХ</b>. В большинстве современных языков программирования, включая Python, целочисленный формат обозначается как <c>int</c> (от слова integer).
<defblock><def>тип данных</def> - в языках программирования: формат считывания последовательности нулей и единиц, соответствующий значениям определённого вида.
<def>int</def> - тип данных в языке Python, соответствующий целым числам.</defblock>
Операция <c>bin</c> возвращает строку с двоичной записью числа. Пример: <c>bin(5)</c> вернёт <c>"0b101"</c>.
Операция <c>hex</c> возвращает строку с шестнадцатеричной записью числа. Пример: <c>hex(26)</c> вернёт <c>"0x1A"</c>.

Стоит отметить, что обычно размер целого числа ограничен количеством выделяемых под него битов памяти. В языках семейства C или в Java количество бит указывается явно. Питон сам разбирается с количеством бит и не ограничивает максимальное значение (жертвуя производительностью).

Так же стоит отметить, что обычно первый бит целого числа используют, чтобы показать его знак: 1 если число положительное, 0 если отрицательное.


<h3>Тип данных: число с плавающей точкой.</h3>
Научившись представлять в компьютере целочисленный формат, программисты захотели продвинуться дальше и сделать дробный формат.

Так как для компьютеров было естественно делать вычисления по принципу "в столбик" (то есть поразрядные вычисления с переносом значений между разрядами), то для деления тоже был выбран удобный для вычислений в столбик формат чисел: числа с плавающей точкой. Число с плавающей точкой задаётся двумя целыми числами: <b>мантиссой</b>, содержащей число без точки и <b>порядком</b>, определяющим место точки. Ниже приведён пример использования мантиссы для десятичного числа:
    <pre>Мантисса	Порядок
                -3		-2		-1		0		1		2		3
256346		256.346		2563.46		25634.6		256346.0	2563460.0	25634600.0	256346000.0</pre>
<cite>Сгенерировано этим кодом на python:</cite>
<code>print(f'Мантисса\tПорядок\n\t\t\t', end='')
for i in range(-3, 4):
    print(f'{i}\t\t\t', end='')
mantissa = 256346
print(f'\n{mantissa}\t\t', end='')
mantissa = mantissa / 1000
for i in range(-3, 4):
    print(f'{mantissa:<12}', end='')
    mantissa *= 10</code>

<b>ВАЖНО:</b> Внутри компьютера используется <b>Двоичная мантисса</b>. То есть используется двоичное число и двоичные разряды после точки.
Например, вот так будет представлено число 5.75:

5.75 = 1 * 4   + 0 * 2   + 1 * 1   + 1 * 0.5    + 1 * 0.25 =
       1 * 2^2 + 0 * 2^1 + 1 * 2^0 + 1 * 2^(-1) + 1 * 2^(-2) = 0b101.11

Таким образом, из двух целых чисел получается число с плавающей точкой. По-английски "плавающий" - <b>float</b>

<defblock><def>float</def> - тип данных в языке Python, соответствующий дробным числам.</defblock>

Стоит отметить, что использование <b>float</b> сопряжено с неточностями. Например, невозможно точно представить в двоичном формате <b>float</b> значение 1/3. Алгоритмы округления помогают, но не решают проблему целиком. Поэтому в системах требующих высокой точности всё равно приходится писать поддержку полноценных дробей.


<h3>Форматы: от целых чисел к строкам.</h3>

Первой крупной "коммерческой" (то есть по-настоящему оплачиваемой) задачей, которую решали компьютеры, было шифрование. То есть требовалось представлять не только числа, но и строки текста.
Научившись представлять числа, создатели компьютеров решили поставить каждому печатному символу в точное соответствие одно число. Получились кодовые таблицы. Примеры кодовых таблиц:
<ul><li>Таблица ASCII, которая широко использовалась в 90е: <a href="https://www.industrialnets.ru/files/misc/ascii.pdf">ссылка на PDF</a></li>
    <li>Современная таблица Unicode: <a href="https://unicode-table.com/ru/#basic-latin">ссылка</a></li>
</ul>
Таким образом, любая строка может быть представлена как последовательность числовых кодов:
Символы:	'л'  	'ю'  	'б'  	'а'  	'я'  	' '  	'с'  	'т'  	'р'  	'о'  	'к'  	'а'
Коды (unicode):	'1083'	'1102'	'1073'	'1072'	'1103'	'32'	'1089'	'1090'	'1088'	'1086'	'1082'	'1072'</pre>
<cite>Сгенерировано этим кодом на python:</cite>
<code>line = 'любая строка'

print("Символы:\t", end='')
formatter = "'{}'"
for symbol in line:
    print(f"\t{formatter.format(symbol):5}", end='')

print("\nКоды:\t\t", end='')
for symbol in line:
    print(f"\t'{ord(symbol)}'", end='')</code>

Строки оказались очень удобным типом данных, с которым можно делать много интересных операций. Поэтому они представлены во всех языках программирования как <c>string</c>(строка) или <c>str</c>

<defblock><def>str</def> - тип данных в языке Python, соответствующий строкам.</defblock>

Можно получить любой символ строки по индексу в квадратных скобках (первый символ - 0). Пример: <c>"Привет"[2]</c> вернёт <c>"и"</c>.
Любой символ можно преобразовать в число операцией <c>ord</c>. Пример: <c>ord(' ')</c> вернёт 32.
Числа можно преобразовывать в символы операцией <c>chr</c>. Пример: <c>chr(32)</c> вернёт <c>' '</c> - строку, в которой только пробел.


<h3>Тип данных: булево значение (и пара слов о комбинированных форматах).</h3>

Булево значение может принимать только одно из двух значений - <b>True</b> (Истина) или <b>False</b> (Ложь). Эти значения соответствуют одному биту данных (1 или 0) и используются в разного рода условных операторах.
Так как современные компьютеры физически неспособны считать из памяти меньше 32 бит за один раз (а у подавляющего большинства этот нижний предел уже 64 бита), то булевы значения обычно вынуждены занимать в памяти 32 бита вместо одного (как будто они лежат в очень большой пустой коробке). Поэтому эти значения часто упаковывают в более сложные типы данных.
Например, состоящие из 32 бит целое число можно считать как в формате int (целое число), а можно - в другом формате, который даёт 32 булевых значения.

Подробнее о сложных форматах, комбинирующих много значений - в более поздних лекциях.
<defblock><def>bool</def> - тип данных в языке Python, соответствующий булевым значениям.</defblock>

<h3>Значения и Форматы: итоги.</h3>
Вы узнали что в памяти компьютера внутри переменных хранятся <b>значения</b>, которые мы можем прочитать благодаря <b>форматам</b>.
Форматы, со своей стороны, привязаны к считываемым с помощью этих форматов <b>типам данных</b>. Вы познакомились с основными типами данных в Питоне:
<ul><li><def>int</def> - целые числа.</li>
    <li><def>float</def> - числа с плавающей точкой.</li>
    <li><def>str</def> - строки.</li>
    <li><def>bool</def> - булевы значения.</li></ul>


<h2>Операции с основными типами данных.</h2>

Поговорив о том, какие основные типы данных есть в Python, обсудим теперь возможные операции над ними.


<h3>Преобразования типов данных.</h3>

В языке программирования Python можно преобразовывать данные одного типа в данные другого типа. Для этого системное название формата используется как операция со скобками.

Несколько примеров:<ul>
    <li><c>str(52)</c> даст строку <c>"52"</c></li>
    <li><c>int("52")</c> даст число 52</li>
    <li><c>int(3.5)</c> отбросит целую часть и даст целое число 3</li>
    <li><c>int(-2.98)</c> отбросит целую часть и даст целое число -2</li>
    <li><c>float(3)</c> даст число 3.0 с типом данных <b>float</b></li>
    <li><c>str(23.845)</c> даст строку <c>"23.845"</c></li>
    <li><c>float("23.845")</c> даст число 23.845</li>
    <li><c>bool(0)</c> даст False, а от любого другого числа - True</li>
    <li><c>bool("")</c> (то есть от пустой строки) даст False, а от любой другой строки - True</li>
    <li><c>str(True)</c> даст строку <c>True</c>(аналогично с False)</li></ul>
    <def>ВНИМАНИЕ:</def> Преобразования из строк в числа могут давать ошибки, если в строке не число:<ul>
    <li><c>float("abc")</c> даст ошибку, потому что не поймёт символ 'а'.</li>
    <li><c>int("0b001")</c> даст ошибку, потому что не поймёт символ 'b'.</li>
    <li><c>int("3.5")</c> даст ошибку, потому что не поймёт символ '.' (в целых нет точек).</li>
    <li><c>float("3,5")</c> даст ошибку, потому что не поймёт символ ',' (дробная часть отделяется точкой).</li></ul>
<h3>Операторы.</h3>

Операторы в Питоне это комбинации из 1 или 2 символов (или иногда 1-2 предлогов), которые могут ставиться перед одним значением (<b>унарные</b> операторы) или соединять 2 значения (<b>бинарные</b> операторы).
Список операторов в Питоне можно найти по <a href = "https://pythonru.com/osnovy/operatory-python">этой ссылке</a>.
Нас пока интересуют только <b>арифметические операторы</b> и <b>оператор присваивания</b>.

<h4>Арифметические операторы:</h4>

Сложение, вычитание и умножение работают вполне обычно:<ul>
    <li><def>Сложение</def>: <c>a + b</c></li>
    <li><def>Вычитание</def>: <c>a - b</c></li>
    <li><def>Умножение</def>: <c>a * b</c></li></ul>
Из-за разделения чисел на целые и плавающие, с делением немного сложно:<ul>
    <li><def>Деление</def>: <c>a / b</c></li>
    <li><def>Деление нацело</def>: <c>a // b</c></li>
    <li><def>Остаток от деления</def>: <c>a % b</c></li></ul>
Так же отдельно от бинарного минуса (вычитание) стоит унарный минус (отрицание):<ul>
    <li><def>Отрицание</def>: <c>-a</c></li></ul>

<h4>Оператор присваивания:</h4>

Любые значения (в том числе рассчитанные с помощью арифметических операторов или полученные операциями преобразования) можно присваивать переменным.<ul>
    <li><def>Присваивание</def>: <c>variable_name = (5 + 8) * 10</c></li></ul>
Оператор присваивания выполняет следующий алгоритм действий:<ol>\
    <li>Определение порядка выполнения операций в правой части (после '=').</li>
    <li>Выполнение операций, получение результата в виде информации о типе данных и значения в форме последовательности 0 и 1, выстроенной в соответствующем типу формате.</li>
    <li>Определение места в памяти компьютера, соответствующего названию переменной.</li>
    <li>При отсутствии такого места - резервирование места под новую переменную.</li>
    <li>Сохранение в памяти, соответствующей названию переменной, информации о типе данных и последовательности 0 и 1.</li></ol>
Несколько примеров без арифметических операторов:<ul>
    <li><c>a = 5</c> сохранит в переменной a значение 5 в типе данных int.</li>
    <li><c>a = "5"</c> сохранит в переменной a значение "5" в типе данных str.</li>
    <li><c>a = 5.0</c> сохранит в переменной a значение 5.0 в типе данных float.</li>
    <li><c>a = True</c> сохранит в переменной a значение True в типе данных bool.</li></ul>
Несколько примеров с арифметическими операторами:<ul>
    <li><c>a = 5 + 3</c> сохранит в переменной a значение 8 в типе данных int.</li>
    <li><c>a = 5 + 3.0</c> сохранит в переменной a значение 8.0 в типе данных float.</li>
    <li><c>a = 5 / 4</c> сохранит в переменной a значение 1.25 в типе данных float.</li>
    <li><c>a = 5 // 4</c> сохранит в переменной a значение 1 в типе данных int.</li>
    <li><c>a = "abc" + "def"</c> сохранит в переменной a значение "abcdef" в типе данных str.</li>
    <li><c>a = "abc" * 3</c> сохранит в переменной a значение "abcabcabc" в типе данных str.</li></ul>
Оператор присвоения затирает предыдущее значение переменной:<ul>
    <li><c>a = 5 + 3</c> внутри a значение 8 в типе int</li>
    <li><c>a = a / 4</c> теперь внутри a значение 2.0 в типе float.</li>
    <li><c>b = str(a)</c> внутри b значение "2.0" в типе str.</li>
    <li><c>c = a * 5</c> внутри c значение 10.0 в типе float.</li>
    <li><c>c = b * 5</c> внутри c значение "2.02.02.02.02.0" в типе str.</li></ul>
Хотя Питон и пытается предоставить максимальную свободу при использовании бинарных операторов, в некоторых случаях такие операции не имеют смысла и приводят к ошибкам:<ul>
    <li><c>c = a + b</c> a это float, b это str. Нельзя сложить число и строку.</li>
    <li><c>c = b * a</c> a это float, b это str. Нельзя повторить строку дробное число раз.</li>
    <li><c>c = -b</c> b это str. Нельзя отрицать текст (можно отрицать его существование или его смысл, но сам текст отрицать бессмысленно :D).</li></ul>
В таких случаях надо приводить данные к нужным типам:<ul>
    <li><c>c = a + float(b)</c> с станет 4.0.</li>
    <li><c>c = b * int(a)</c> c станет "2.02.0"</li></ul>

<h4>Сокращённое присваивание:</h4>
В ситуации когда нужно изменить переменную, применив какой-то оператор с ней самой, может использоваться сокращённая запись:<ul>
    <li><c>a = a + b</c> идентично <c>a += b</c></li>
    <li><c>a = a * b</c> идентично <c>a *= b</c></li>
    <li><c>a = a // b</c> идентично <c>a //= b</c></li>
    <li>... аналогично с другими бинарными операторами</li></ul>

<h3>Операции с типами данных: итоги.</h3>
Мы разобрали преобразования между типами данных и работу операторов, включая арифметические операторы и операторы присваивания.
Это не все операции, которые возможны с типами данных и переменными. У нас осталось ещё минимум две крупные группы - индексирование и встроенные операции.
Но для начала, я думаю, вполне достаточно :)

На этом лекция завершена, удачи на семинарах!
</body>
