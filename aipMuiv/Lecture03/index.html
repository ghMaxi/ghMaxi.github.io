<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../lecture.css" media="screen" />
    <title>Лекция 3 - Алгоритмизация и программирование</title>
</head>
<body>
    <h1>Материалы курса Алгоритмизации и Программирования<br>
    Лекция 3 - встроенные функции типов данных.</h1>
    <cite>Преображенский М.В. 2021/22</cite>
    <p>На этой лекции мы подробно обсудим встроенные возможности типов данных вообще и конкретно встроенные возможности
        типа данных str.</p>
    <h2>Понятия вызываемости и индексируемости.</h2>
    <p>На прошлой лекции мы поговорили о "сырых" типах данных: <b>int</b>, <b>float</b>, <b>bool</b> и <b>str</b>, а так
        же об операторах, позволяющих осуществлять простые операции с этими типами.</p>
    <p>Сегодня мы обсудим функционал типов данных, выходящий за пределы простых операций. Для этого нам надо будет
        поговорить о двух свойствах типов данных: <b>индексируемость</b> и <b>вызываемость</b>.
    <p><span class="inline definition"><b class="define">Вызываемые (Callable)</b> - значения, поддерживающие оператор
        вызова (круглые скобки). Пример: <b>input()</b> <- круглые скобки означают вызов.
        <br><b class="define">Индексируемые</b> (прямой перевод с английского -
        <b class="define">Подписные (subscriptable)</b> - типы данных, поддерживающие оператор
        получения внутреннего элемента (квадратные скобки). Например из строки
        "Привет" можно достать букву "П", написав "Привет"[0]</span></p>
    <p>Термины <b>Callable</b> и <b>Subscriptable</b> полезно знать, потому что они появляются в отчётах об ошибках.
        Попробуйте, например, вызвать такой код:</p>
    <pre>a = 5
a()</pre>
    <p>Или такой:</p>
    <pre>a = 5
print(a[0])</pre>
    <h2>Встроенные возможности типа данных <b>str</b>.</h2>
    <p>В отличие от типов данных int, bool и float, тип данных <b>str</b> поддерживает индексирование.
       Он так же содержит внутри себя значительно большее количество <b>вызываемых</b> методов.</p>
    <h3>Возможности индексирования строк.</h3>
    <p><span class="inline definition"><b class="define">Индексом</b> называется значение, указывающее на расположение элемента в коллекции.
        Конкретно строки индексируются с помощью чисел таким образом, что число 0 соответствует первому символу строки.
        <br><b class="define">Нулевая индексация</b> - весьма распространённая практика числовой индексации, в которой
        первый элемент имеет индекс 0, а индекс любого элемента вообще на 1 меньше его номера.</span></p>
    <p>Таким образом, Вы можете получить доступ к любой букве строки по её индексу. Индексы могут быть отрицательными
        (и тогда будет браться элемент с конца строки). Они так же могу превышать длину строки (и тогда отсчёт пойдёт
        заново по кругу). Примеры:</p>
    <pre>line = "Hello, world"
print(line[0])  # Выведет H
print(line[-3])  # Выведет r
print(line[20])  # Ошибка IndexError: string index out of range</pre>
    <p>Обычно числовое индексирование так же предполагает возможность получения <b>среза</b></p>
    <p><span class="inline definition"><b class="define">Срез</b>, - способ получить из коллекции с числовым
        индексированием новую коллекцию, включающую в себя только нужный набор индексов.
        <br>Срезы задаются по правилам <b>арифметической последовательности</b> - начало, недостижимая граница, шаг.
    </span></p>
    <p>Примеры:</p>
<pre>line = "Hello, world"
print(line[4:])    # Первые 4 символа ("Hell")
print(line[:-4])   # Все символы до 4го с конца ("Hello, w")
print(line[3:-4])  # Все символы с 4го (индекс 3) до 4го с конца ("lo, w")
print(line[::2])   # Каждый второй символ, начиная с первого ("Hlo ol")
print(line[1::2])  # Каждый второй символ, начиная со 2го (индекс 1, "el,wrd")
print(line[::-1])  # Все символы в обратном порядке ("dlrow ,olleH")</pre>
    <h3>Вызываемые команды в строках.</h3>
    <p>Все представители класса str содержат вызываемые команды, которые можно увидеть, если в поддерживающем
       автозаполнение IDE написать точку после строки:</p>
    <img src="./dot_after_str.png">
    <p>При работе с IDE без автозаполнения всегда можно обратиться к документации:</p>
    <ul><li>Методы класса <b>str</b> на русском: <a href="https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/">Здесь</a></li>
        <li>Методы класса <b>str</b> оригинальная: <a href="https://docs.python.org/3/library/stdtypes.html#string-methods">Здесь</a></li></ul>
    <p>Знать полезно все эти методы, но наиболее важными являются:</p>
    <ul><li><b>"строка".find("подстрока")</b> - ищет индекс первого вхождения подстроки в строку.
        Возвращает -1 если не находит.</li>
        <li><b>"строка".isdigit()</b>, а так же другие начинающиеся с <b>is</b> проверки - проверяют состав строки, возвращаю
            truе или false. Например, isdigit() вернёт true если строка состоит из цифр</li>
        <li><b>"строка".upper()</b> и <b>"строка".lower()</b> - возвращают ту же строку, но только большими (или маленькими) буквами</li>
        <li><b>"строка".join("другая строка")</b> - вставляет исходную строку между каждыми элементами переданной строки</li>
        <li><b>"строка".replace("что заменить", "чем")</b> - заменяет все вхождения первого аргумента вторым</li>
        <li><b>"строка с пробелами".split()</b> - делит строку на части по пробелам, табам, разрывам строки итд.</li>
    </ul>
    <h2>Ещё несколько встроенных функций.</h2>
    <p>Кроме методов класса <b>str</b> так же доступны общие методы и операции для последовательностей с числовыми
        индексами:
    <ul><li>Документация на русском: <a href="https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/">Здесь</a></li>
        <li>Оригинальная документация: <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-common">Здесь</a></li></ul>
    <p>Хотелось бы отдельно выделить следующие:</p>
    <ul><li>Проверка <b>in</b>, которая проверяет наличие подстроки в строке</li>
        <li>Метод <b>len("строка")</b>, возвращающий длину строки</li>
        <li>Метод <b>"строка".count("подстрока")</b>, возвращающий количество вхождений подстроки в строку</li></ul>
    <h2>Итоги: Пример программы, работающей со строками:</h2>
    <p>Разберите небольшую программу, которая могла бы проверять правильность ввода номера телефона:</p>
    <pre>
def main(line):
    line = ''.join(line.split())
    if line[0] == '8':
        line = f'+7{line[1:]}'
    if (line[0] != '8' and line[:2] != '+7') \
       or line[0] == '-' or line[-1] == '-' or line.count('--') > 0\
       or line.count(')') != line.count('(') or line.count('(') > 1\
       or (line.count(')') > 0 and line.index('(') > line.index(')')):
        return 'error'
    else:
        line = line.replace('-', '').replace(')', '').replace('(', '')
        return line if len(line) == 12 else 'error'


if __name__ == "__main__":
    print(main(input()))
</pre>
    <p>Попробуйте разобраться, по каким правилам эта программа проверяет телефоны.
        Можете ли назвать какие-то входные строки, при которых эта программа даст неправильный результат?</p>
    <p>На этом лекция завершена, удачи на семинарах!</p>
</body>
