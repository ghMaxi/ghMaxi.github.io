<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" type="text/css" href="../../../style.css" media="screen" />
    <title>Лекция 3 - Алгоритмизация и программирование</title>
</head>
<body><h1>Материалы курса <a href="../">Алгоритмизации и Программирования</a></h1>
<cite>Преображенский М.В. 2021/22</cite>

<h1>Лекция 3 - встроенные функции типов данных.</h1>

На этой лекции мы подробно обсудим встроенные возможности типов данных вообще и конкретно встроенные возможности типа данных <c>str</c>.

<h2>Понятия вызываемости и индексируемости.</h2>

На прошлой лекции мы поговорили о "сырых" типах данных: <c>int</c>, <c>float</c>, <c>bool</c> и <c>str</c>, а так же об операторах, позволяющих осуществлять простые операции с этими типами.
Сегодня мы обсудим функционал типов данных, выходящий за пределы простых операций. Для этого нам надо будет
поговорить о двух свойствах типов данных: <b>ИНДЕКСИРУЕМОСТЬ</b> и <b>ВЫЗЫВАЕМОСТЬ</b>.

<defblock><def>Вызываемые (Callable)</def> - значения, поддерживающие оператор вызова (круглые скобки). Пример: <b>input()</b> <- круглые скобки означают вызов.
<def>Индексируемые</def> (прямой перевод с английского - <def>Подписные (subscriptable)</def>) - типы данных, поддерживающие оператор получения внутреннего элемента (квадратные скобки). Например из строки "Привет" можно достать букву "П", написав "Привет"[0]</defblock>

Термины <c>Callable</c> и <c>Subscriptable</c> полезно знать, потому что они появляются в отчётах об ошибках.

Попробуйте, например, вызвать такой код:

<c>a = 5
a()</c>

Или такой:
<c>a = 5
print(a[0])</c>


<h2>Встроенные возможности типа данных <b>str</b>.</h2>

В отличие от типов данных int, bool и float, тип данных <b>str</b> поддерживает индексирование.
   Он так же содержит внутри себя значительно большее количество <b>вызываемых</b> методов.

<h3>Возможности индексирования строк.</h3>

<defblock><def>Индексом</def> называется значение, указывающее на расположение элемента в коллекции. Конкретно строки индексируются с помощью чисел таким образом, что число 0 соответствует первому символу строки.
<def>Нулевая индексация</def> - весьма распространённая практика числовой индексации, в которой первый элемент имеет индекс 0, а индекс любого элемента вообще на 1 меньше его номера.</defblock>

Таким образом, Вы можете получить доступ к любой букве строки по её индексу. Индексы могут быть отрицательными (и тогда будет браться элемент с конца строки). Они так же могу превышать длину строки (и тогда отсчёт пойдёт заново по кругу).

Примеры:

<c>line = "Hello, world"
print(line[0])  # Выведет H
print(line[-3])  # Выведет r
print(line[20])  # Ошибка IndexError: string index out of range</c>

Обычно числовое индексирование так же предполагает возможность получения <b>среза</b>

<defblock><def>Срез</def>, - способ получить из коллекции с числовым индексированием новую коллекцию, включающую в себя только нужный набор индексов. Срезы задаются по правилам <b>арифметической последовательности</b> - начало, недостижимая граница, шаг.</defblock>

Примеры:
<c>line = "Hello, world"
print(line[4:])    # Первые 4 символа ("Hell")
print(line[:-4])   # Все символы до 4го с конца ("Hello, w")
print(line[3:-4])  # Все символы с 4го (индекс 3) до 4го с конца ("lo, w")
print(line[::2])   # Каждый второй символ, начиная с первого ("Hlo ol")
print(line[1::2])  # Каждый второй символ, начиная со 2го (индекс 1, "el,wrd")
print(line[::-1])  # Все символы в обратном порядке ("dlrow ,olleH")</c>


<h3>Вызываемые команды в строках.</h3>

Все представители класса str содержат вызываемые команды, которые можно увидеть, если в поддерживающем
   автозаполнение IDE написать точку после строки:

<img src="./dot_after_str.png">

При работе с IDE без автозаполнения всегда можно обратиться к документации:<ul>
    <li>Методы класса <b>str</b> на русском: <a href="https://docs-python.ru/tutorial/operatsii-tekstovymi-strokami-str-python/">Здесь</a></li>
    <li>Методы класса <b>str</b> оригинальная: <a href="https://docs.python.org/3/library/stdtypes.html#string-methods">Здесь</a></li></ul>
Знать полезно все эти методы, но наиболее важными являются:<ul>
    <li><b>"строка".find("подстрока")</b> - ищет индекс первого вхождения подстроки в строку. Возвращает -1 если не находит.</li>
    <li><b>"строка".isdigit()</b>, а так же другие начинающиеся с <b>is</b> проверки - проверяют состав строки, возвращаю
        truе или false. Например, isdigit() вернёт true если строка состоит из цифр</li>
    <li><b>"строка".upper()</b> и <b>"строка".lower()</b> - возвращают ту же строку, но только большими (или маленькими) буквами</li>
    <li><b>"строка".join("другая строка")</b> - вставляет исходную строку между каждыми элементами переданной строки</li>
    <li><b>"строка".replace("что заменить", "чем")</b> - заменяет все вхождения первого аргумента вторым</li>
    <li><b>"строка с пробелами".split()</b> - делит строку на части по пробелам, табам, разрывам строки итд.</li></ul>
<h2>Ещё несколько встроенных функций.</h2>

Кроме методов класса <b>str</b> так же доступны общие методы и операции для последовательностей с числовыми индексами:<ul>
    <li>Документация на русском: <a href="https://docs-python.ru/tutorial/obschie-operatsii-posledovatelnostjami-list-tuple-str-python/">Здесь</a></li>
    <li>Оригинальная документация: <a href="https://docs.python.org/3/library/stdtypes.html#typesseq-common">Здесь</a></li></ul>
Хотелось бы отдельно выделить следующие:<ul>
    <li>Проверка <b>in</b>, которая проверяет наличие подстроки в строке</li>
    <li>Метод <b>len("строка")</b>, возвращающий длину строки</li>
    <li>Метод <b>"строка".count("подстрока")</b>, возвращающий количество вхождений подстроки в строку</li></ul>
<h2>Итоги: Пример программы, работающей со строками:</h2>

Разберите небольшую программу, которая могла бы проверять правильность ввода номера телефона:

<c>def main(line):
    line = ''.join(line.split())
    if line[0] == '8':
        line = f'+7{line[1:]}'
    if (line[0] != '8' and line[:2] != '+7') \
       or line[0] == '-' or line[-1] == '-' or line.count('--') > 0\
       or line.count(')') != line.count('(') or line.count('(') > 1\
       or (line.count(')') > 0 and line.index('(') > line.index(')')):
        return 'error'
    else:
        line = line.replace('-', '').replace(')', '').replace('(', '')
        return line if len(line) == 12 else 'error'


if __name__ == "__main__":
    print(main(input()))</c>

Попробуйте разобраться, по каким правилам эта программа проверяет телефоны.
Можете ли назвать какие-то входные строки, при которых эта программа даст неправильный результат?

На этом лекция завершена, удачи на семинарах!
</body>
